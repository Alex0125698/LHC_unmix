# Uses the Algorithm 'Block-Simultaneous Method of Multipliers' to perform
# matrix factorisation with non-negative and sum-to-one constraint hence making
# it appropriate for hyperspectral unmixing. (See Report for more details)
# --- Inputs ---
# file 'hsuDataIn.mat' containing the 
# --- Outputs ---
# file 'hsuDataOut.mat'
#
# by A.S. Woodcock 03/NOV/2019
# adapted from 'unmixing.py' by Moolekamp & Melchior

import numpy as np
import proxmin
from proxmin.utils import Traceback
from scipy.optimize import linear_sum_assignment
import matplotlib.pyplot as plt
import time
from functools import partial
import scipy.io
import logging

# looks like Melchior was using a transposed version of 
# the problem: Y^t = S^t M^t + W^t
# Melchior re-labels: S^t as A; and M^t as S

if __name__ == "__main__":

    # load matrices generated by Matlab
    mat = scipy.io.loadmat('data/hsuDataIn.mat')

    # Transpose into Melchior's format
    # trueSt = np.transpose(mat['S']) # now nPixels x nEndmems
    trueMt = np.transpose(mat['M']) # now nEndmems x nBands
    Yt     = np.transpose(mat['Y']) # now nPixels x nBands

    nBands   = trueMt.shape[1] # number of frequency bands
    nEndmem  = trueMt.shape[0] # number of endmembers / components
    nPixels  = Yt.shape[0]     # number of pixels / observations

    # start of with random Mixing & Abundance matrices
    # perhaps initialising with another algorithm could be an improvement
    St = np.random.rand(nPixels,nEndmem)
    Mt = np.random.rand(nEndmem,nBands)

    # mixture model: amplitudes positive
    # and sum up to one at every pixel
    proxSt = partial(proxmin.operators.prox_unity_plus, axis=1)
    proxMt = proxmin.operators.prox_plus

    # this runs the algorithm and returns results in St and Mt
    proxmin.nmf(Yt, St, Mt, prox_A=proxSt, prox_S=proxMt, e_rel=1e-6, max_iter=200)

    # save results in Matlab format; need to transpose back to correct orientation
    scipy.io.savemat('data/hsuDataOut.mat', { 'Malg':np.transpose(Mt), 'Salg':np.transpose(St) })